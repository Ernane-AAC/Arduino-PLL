<!--Project webpage for Arduino PLL and Frequency Meter-->
<!DOCTYPE html>
<html>
<head>
   <title> Arduino PLL and Frequency Meter </title>
   <link rel="stylesheet" type="text/css" href="styles.css">
   <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
   <h1> Arduino PLL and Frequency Meter</h1>
   <div class="content1">
       <h3> Motivation </h3>
       <ul> 
          <li> PLL (Phase Locked Loop) is a feedback control system that produces an output signal which phase presents a constant difference to the phase of the applied input signal.</li>
		  <li> PLLs are used in several applications like communication systems, clock signal generation in microprocessors and microcontrollers.</li>
          <li> PLLs have recently gained interest due to its application in PV (Photovoltaic) grid-connected systems.</li>
 	      <li> The purpose of this project is to present in a simple way how the digital PLL algorithm works and how we can measure the grid frequency using it. Thus, the simplest PLL algorithm is considered and executed in Arduino Uno (Atmega328p).</li>
 	      <li> Considering the didactic purpose of the project, it was used a simple algorithm running in a simple microcontroller, but it is important to keep in mind that the simplest PLL algorithm is not suitable for many applications since, as instance, it presents frequency oscillations around the equilibrium point. </li>		  
          <li> We can find more sophisticated PLL algorithms in literature, but certainly they will require a more powerful microcontroller.</li>
       </ul>
    </div>
    <div class="content2">
        <h3> The Plant -  Phase Locked Loop </h3>
		<ul>
           <li>The simplest PLL scheme is shown in Fig.1. It is composed of three subsystems: the phase detector (multiplier), the filter loop (PI compensator) and the VCO (Voltage-controlled oscillator).</li>
           <li>The PI Compensator acts like a low-pass filter that extract the average value of product between the Vq signal, generated by the VCO, and the input signal. The frequency of the Vq signal is determined by the PI controller.  As the PI controller integrates the average value of product of the signals, in order to achieve the equilibrium, the loop has the find the Vq frequency for which the average value is zero. This happens when the signals are orthogonal, that is, they have the same frequency and are 90 degrees out of phase. </li>
           <li>An easy way to understand that is to consider, as instance, the input signal as a voltage and the VCO Vq signal as a current, thus, the phase detector output will be the instantaneous power, and the loop filter output will provide the average power. If the voltage and current (same frequency) are 90 degrees out of phase, the average power is zero. If the frequency is not the same, the average power is not constant, it will change according the difference between the frequencies of the signals. In this case, the equilibrium point hasn't achieved yet. </li>
           <li>When the steady state is achieved, the Vq signal is 90 degrees out of phase with input signal and Vd is equal in phase and frequency with it.</li> 
        </ul>
        <figure>
           <img src="PLL_scheme.png" style="width:60%">
		   <figcaption>Fig.1 - Basic PLL Scheme</figcaption>
        </figure>
    </div>		
	<div class="content3">
        <h3> PLL Input/Output Signals - Voltage and Current Analogy</h3>
		<ul>
           <li> Fig.2. shows what happens to the average power when the current and voltage signals have different frequencies (<i>&#969<sub>1</sub> and &#969<sub>2</sub></i>).  As we can see, the average power is not constant, instead, it  presents an oscillation at the frequency (<i>&#969<sub>1</sub> - &#969<sub>2</sub></i>). </li>		
           <li> Note that, due to the distinct frequencies, as time goes by, the phase difference between signals changes, affecting the average value of the instantaneous power. Then, in order to achieve a constant average power, the controller has to force the VCO to move to the same frequency of the input signal.</li> 
		   <li> Fig.3 shows what happens to the average power when the current and voltage signals have same frequency (<i>&#969<sub>1</sub> = &#969<sub>2</sub></i>). In this case, the graph presents the instantaneous and average power when only the phase of current is changing. As we can see, if the average power is constant, the phase of the Vq signal keeps a constant relationship with the phase of the input signal. As the controller presents an integral action, when steady state is reached, the average value at the controller input must be zero. It means that the signal Vq has the same frequency of the input signal and Vq is 90 degrees out of phase with it. Then, Vd and the input signal have same frequency and phase, they are <i>locked</i>.</li>
           <li> The reader has to keep in mind that the voltage, the current and the instantaneous power presented in Figs. 2 and 3 imply only an analogy to make the PLL comprehension easy. They have no relationdship to a specific RLC circuit. </li>
		</ul>
		<table>
          <tr>
		    <td>
              <figure>
                <img src="Power_Animation_w_deviation.gif" style="width:80%">
		        <figcaption>Fig.2 - Inner product of signals with distinct frequencies</figcaption>
              </figure>
		    </td>
		    <td>
              <figure>
                <img src="Power_Animation.gif" style="width:80%">
		        <figcaption>Fig.3 - Inner product of signals, same frequency, distinct phases</figcaption>
              </figure>
			</td>
		  </tr>
	    </table>			
    </div>
	<div class="content4">
        <h3> PLL Control Design </h3>
		<ul>
           <li>PLL is a non-linear control system and its design is not trivial. Generally, a small signal model is used to determine the control parameters, which corresponds to a linearization around an operating point. </li>
           <li>In the current project, we consider the design presented in [1]. </li>
		   <li>The PI Compensator parameters are: </li>
		      <ul>
                 <li>K<sub>p</sub> = 92 (V<sup>2</sup>s/rad) </li>
				 <li>T<sub>i</sub> = 0.0217 (s) </li>
              </ul>
		   <li>As can be seen in [1], the design consider a settling time of 100 ms. This implies a dynamic behaviour in the PLL loop that results in some level of oscillation in frequency in the steady state. It is possible to change the loop filter function to reduce the level of oscillation, but certainly this will imply a slow dynamic behaviour in the PLL loop. If your application needs a better solution, see other options in [1],[2], but probably a more powerful microcontroller will be required.</li>  
           <li>It is important to emphasize that the parameters above imply that the input signal and Vq signal are in pu (per unit value). The gain and offset of the ADC system need to be adjusted for that. See more details in <a href="https://ernane-aac.github.io/RMS-Voltage-Measurement/">RMS Voltage Measurement Using Arduino UNO</a>.  </li>
           <li>In order to achieve real time execution in Arduino, a sampling rate of 4kHz is used. Thus, converting the PI parameters to the discrete version at this sampling rate and using the zero-order-hold method, we have: </li>
		        $$ G_{PI}(z)=\frac{92z-90.94}{z-1} \ (1)$$
		</ul>		
    </div>
	<div class="content5">
        <h3> PLL Performance </h3>
		<ul>
		   <li>Fig. 4 presents a simulation result of the designed PLL for a positive frequency jump of 10Hz applied to the input signal at 0.15s, and a negative frequency step of -20Hz applied to the input signal at 0.35s. As we can see, the PLL frequency follows the input frequency, keeping the signal Vd and the input signal equal in phase and frequency (average value).</li>		
		   <li>The same plant is simulated again, but now a positive phase jump of &#960/2 is applied to the input signal at 0.15s, and a negative phase jump of -&#960/2 applied to the input signal at 0.35s. The result is presented in Fig. 5. Again, we can see that the PLL loop is able to synchronize the signals after the input transient. </li>
		</ul>
		<table>
          <tr>
		    <td>
              <figure>
                <img src="PLL_Frequency_response.png" style="width:80%">
		        <figcaption>Fig.4 - PLL Phase and Frequency Response - Input Signal Frequency jumps at 0.15s and 0.35s</figcaption>
              </figure>
		    </td>
		    <td>
              <figure>
                <img src="PLL_Phase_response.png" style="width:80%">
		        <figcaption>Fig.5 - PLL Phase and Frequency Response - Input Signal Phase jumps at 0.15s and 0.35s </figcaption>
              </figure>
			</td>
		  </tr>
	    </table>
		<ul>
		   <li> Figs 6 and 7 show the PLL operation in the steady state condition, in continuous time and discrete time (sampling rate of 4kHz), respectively. </li>
		   <li> Looking to these Figures, the reader can notice that the Vd signal is not a perfect sinusoidal signal. This happens because the its frequency is not a constant, like it is for the input signal. It is like a car on a race track. The speed changes according the position of the car in the race track, but the average speed  (average frequency) will be constant if the lap time (period) is constant. The simplest PLL algorithm is affected by the average speed (average frequency). If the loop filter has a high bandwidth, this will imply fast changes in the average value and a fast dynamic behaviour of the PLL, however, this will result in a high level of frequency oscillations and more distortions in the VCO signals. It is not the objective of this project to discuss this point in details. See more details in [1],[2].</li>
		</ul>
		<table>
          <tr>
		    <td>
              <figure>
                <img src="PLL_zoom_continuous_time.png" style="width:80%">
		        <figcaption>Fig.6 - PLL Phase and Frequency Response (steady state - continuous time)</figcaption>
              </figure>
		    </td>
		    <td>
              <figure>
                <img src="PLL_zoom_discrete_time.png" style="width:80%">
		        <figcaption>Fig.7 - PLL Phase and Frequency Response (steady state - discrete time -sampling rate of 4 kHz) </figcaption>
              </figure>
			</td>
		  </tr>
	    </table>
		
    </div>		
	<div class="content6">
        <h3> PLL Test</h3>
		<ul>
           <li> In order to verify the operation of the digital PLL in Arduino, a second Arduino board was used. This second unit run a code of a signal generator and it is connected to the first unit as presented in Fig.8 </li>
           <li> The signal generator code applies a sequence of several transients at the PLL input: </li>
		   <ul>
		      <li> It starts with a sinusoidal signal at 60Hz; </li>
			  <li> At t=20s, it increases the frequency to 70Hz; </li>
			  <li> At t=40s, it decreases the frequency to 50Hz; </li>
			  <li> From t=50s to t=70s, it applies a frequency ramp from 50 to 60Hz (+0.5 Hz/s); </li>	
              <li> At t=90s, it it applies a phase jump of &#960/2 in the input signal. </li>			  
		   </ul>
		   <li> The complete PLL code that runs in Arduino 1 (Fig.8) is presented below. The PLL is executed by the ADC interrupt service routine (ISR), and the ADC is triggered by timer 1 at each 250&#181s (4kHz).</li>   
		   <li> The sine and cosine calculations of the AVR Math Library take more than 100 &#181s to be executed, so, to avoid the spending of this time, a lookup table (LUT) strategy is used.  The duration of calculating the trigonometric functions is presented in Table I.</li>			  
        </ul>
		<figure>
            <img src="System_Test_Diagram.png" style="width:50%">
		    <figcaption>Fig.8 - Scheme for the PLL Test </figcaption>
        </figure>		
		<table class="table1">
		<caption>Table I - Duration of calculating trigonometric functions</caption>
         <tr>
           <th>Function</th>
           <th>Duration in cycles*</th>
           <th>Duration in &#181s</th>
         </tr>
		 <tr>
           <th>Sin(&#960/2)(AVR Math Lib)</th>
           <th>1717</th>
           <th>107.3</th>
         </tr>
		 <tr>
           <th>Cos(&#960/2)(AVR Math Lib)</th>
           <th>1798</th>
           <th>112.4</th>
         </tr>	
		 <tr>
           <th>Sin(&#960/2) [LUT](index calculation and table access) </th>
           <th>748</th>
           <th>46.8</th>
         </tr>	
		 <tr>
           <th>Cos(&#960/2) [LUT] (only index offset and table access)** </th>
           <th>43</th>
           <th>2.7</th>
         </tr>			 
		</table>
		<p> *The duration in number of cycles was measured using the timer 1 of the Atmega328p running with a clock of 16 MHz. See the way you can measure a time that a given code snippet takes to be executed in <a href="https://www.youtube.com/watch?v=6-wAuRkBT1Y">RMS Voltage Measurement Using Arduino</a></p>
        <p> **The cosine is calculated using the sine table (200 samples for entire period), considering the normalized angle shifted in 1/4 of the period (50 points). This is calculated using the normalized angle converted to integer in the previous sine calculation, which is faster than to convert the angle from float to integer. Thus, in this case, the cosine value is obtained faster. </p> </p>		
		<ul>
           <li> The atmega328p microcontroller (Arduino Uno) has no D/A converter. It is possible to use an external one (MCP4725) connected by the I2C bus, but as we can see in <a href="https://ernane-aac.github.io/MCP4725_Fast_Write_Access/">Fast Function to Write Samples in the MCP4725</a>, the write access to this device takes at least 76&#181s and probably this would compromise the real time operation in the desired sampling rate. In this case, a faster solution was considered, a PWM output and a passive low-pass filter, acting as a D/A converter. The sample update takes only the time needed to write it in compare register.</li>
           <li> In order to verify if it is possible to run the complete code in real time at 4kHz, set/reset gpio commands were inserted in the ADC interrupt code, and the correspondent signal is show in Fig. 9. As we can see the ADC interrupt code takes around 195 &#181s to be executed, 78% of the sampling period (250&#181s).
	    </ul>
		<figure>
            <img src="ISR_duration.png" style="width:40%">
		    <figcaption>Fig.9 - ADC interrupt pulse for real time execution verification </figcaption>
        </figure>				
		<ul>
		   <li> The passive low-pass filters (LPF) shown in Fig.8 are identical and present the following characteristics: </li>
		   <ul>
              <li> Two cascaded RC sections
		      <li> R = 3.3k&#937 </li>	
			  <li> C = 100nF </li>
              <li> Neglecting the effect of loading from one section on the other (small in this case), we can say that the filter has a cut-off frequency of 482.3 Hz and presents an attenuation around of -37dB (x0.0141) at 4kHz, which is enough to remove the carrier from the PWM signal.</li> 			  
		   </ul>    
		   <li> It is important to emphasize that the use of the passive LPF to separate the modulating signal from the PWM carrier results in a phase delay. The reader must take this into account when comparing signals in the oscilloscope. </li>		   
           <li> A link for a video with the PLL test in the actual plant is presented below. </li>
	    </ul>
	</div>	
	<div class="content7">
        <h3> Grid Frequency Meter </h3>
		<ul> 
		   <li>As can be seen in Figs. 6 and 7, the PLL frequency, even in the steady state, presents a significant ripple at at the double of the frequency of the input signal. In order to show the average frequency in a LCD, a digital first order low-pass filter is used. This filter doesn't affect the PLL dynamics, since it is not a part of the PLL feedback loop. Besides that, it is simple and implies a small computational burden.</li> 
		   <li>The digital first order low-pass filter (LPF) presents the following characteristics: </li>
		   <ul>
		      <li> Sampling rate = 4 kHz;</li>
		      <li> Cut-off frequency = 0.12 Hz</li>
		      <li> Transfer function:</li>		   
	             $$ G_{LPF}(z)=\frac{0.00157}{z-0.99843} \ (2)$$
		   </ul>
           <li>The reader has to keep in mind that it is a simple frequency meter for low frequencies. The principle can be used to design a more sophisticated frequency meter, but it is recommended to use an enhanced PLL algorithm and a more powerful microcontroller.</li>
           <li>In order to measure the grid frequency, it is necessary to connect a voltage sensor and the respective signal conditioner circuit in one of the analog inputs of the Arduino Uno. The scheme of the frequency meter is show in Fig. 10.</li>
           <li>The reader can find a way to implement a voltage sensor in <a href="https://ernane-aac.github.io/RMS-Voltage-Measurement/">RMS Voltage Measurement Using Arduino UNO</a>.</li>
 		   <li>Note that to see the Vd signal (PB1-OC1A PWM output) in oscilloscope, which will be synchronized to the grid voltage,  you need to connect the analog low-pass filter. You have to consider that the use of filter will result in some delay for Vd signal.</li>
		   <li>Depending on the voltage amplitude you are measuring, is is necessary to calibrate the sensor to provide the voltage in pu. You have to remember that the PLL loop filter coefficients were designed considering the inputs of the phase detector in pu.</li>
           <li>The operation of the Frequency Meter in an actual plant can be seen in the video, which the link is presented below.</li>
        </ul>
				<figure>
            <img src="System_Diagram.png" style="width:50%">
		    <figcaption>Fig.10 - Scheme for the PLL and Grid Frequency Meter </figcaption>
        </figure>	
	</div>	
	<div class="content8">
        <h3> Links </h3>
		<ul> 
		   <li><a href="https://github.com/Ernane-AAC/Arduino-PLL/tree/main/PLL_Arduino_Code">Complete Code for the Arduino PLL</a></li>
	       <li><a href="https://youtu.be/9u9lPNp1WoQ">Video showing the PLL Test and the Frequency Meter Running.</a></li>
		</ul>
	</div>
	<div class="content9">
        <h3> References </h3>
        <p>[1] Remus Teodorescu, Marco Liserre and Pedro Rodríguez, Grid Converters for Photovoltaic and Wind Power Systems, John Wiley & Sons, Ltd., 2011, ISBN: 978-0-470-05751-3.</p>
	    <p>[2] Masoud Karimi-Ghartema, Enhanced Phase-Locked Loop Structures for Power and Energy Applications, John Wiley & Sons, 2014, ISBN:‎ 978-1118795026.</p>
	</div>			
</body>
</html>
